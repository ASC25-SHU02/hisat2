#!/usr/bin/env perl
#
# Copyright 2020, Daehwan Kim <infphilo@gmail.com> and Chanhee Park <parkchanhee@gmail.com>
#
# This file is part of HISAT 2.
#
# HISAT 2 is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# HISAT 2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with HISAT 2.  If not, see <http://www.gnu.org/licenses/>.
#

# hisat2-quant:
#
# A wrapper script for hisat2-quant.  Provides various advantages over running
# hisat directly, including:
#
# 1. Handling compressed inputs
# 2. Redirecting output to various files
# 3. Output directly to bam (not currently supported)

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use File::Spec;
use POSIX;

my ($vol,$script_path,$prog);
$prog = File::Spec->rel2abs( __FILE__ );

while (-f $prog && -l $prog){
    my (undef, $dir, undef) = File::Spec->splitpath($prog);
    $prog = File::Spec->rel2abs(readlink($prog), $dir);
}

($vol,$script_path,$prog) 
    = File::Spec->splitpath($prog);
my $os_is_nix   = ($^O eq "linux") || ($^O eq "darwin");
my $quant_bin = $os_is_nix ? 'hisat2-quant-bin' : 'hisat2-quant-bin.exe'; 
my $quant_prog = File::Spec->catpath($vol,$script_path,$quant_bin);
my $seq_in_args = 0;
my %signo       = ();
my @signame     = ();

{
    # Get signal info
    use Config;
    my $i = 0;
    for my $name (split(' ', $Config{sig_name})) {
	$signo{$name} = $i;
	$signame[$i] = $name;
	$i++;
    }
}

(-x "$quant_prog") ||
	Fail("Expected hisat2-quant to be in same directory with hisat2-quant-bin:\n$script_path\n");

my %desc = ();
my %wrapped = ("1" => 1, "2" => 1);

# Given an option like -1, determine whether it's wrapped (i.e. should be
# handled by this script rather than being passed along to HISAT)
sub isWrapped($) { return defined($wrapped{$_[0]}); }

my @orig_argv = @ARGV;

my @ht2w_args = (); # options for wrapper
my @ht2_args  = (); # options for hisat2-quant
my $saw_dd = 0;
for(0..$#ARGV) {
    if($ARGV[$_] eq "--") {
	$saw_dd = 1;
	next;
    }
    push @ht2w_args, $ARGV[$_] if !$saw_dd;
    push @ht2_args,  $ARGV[$_] if  $saw_dd;
}
if(!$saw_dd) {
    @ht2_args = @ht2w_args;
    @ht2w_args= ();
}

my $debug = 0;
my %read_fns = ();
my %read_compress = ();
my $cap_out = undef;       # Filename for passthrough
# Remove whitespace
for my $i (0..$#ht2_args) {
    $ht2_args[$i]=~ s/^\s+//; $ht2_args[$i] =~ s/\s+$//;
}

# We've handled arguments that the user has explicitly directed either to the
# wrapper or to hisat2-quant, now we capture some of the hisat2-quant arguments that
# ought to be handled in the wrapper
for(my $i = 0; $i < scalar(@ht2_args); $i++) {
    next unless defined($ht2_args[$i]);
    my $arg = $ht2_args[$i];
    my @args = split(/=/, $arg);
    if(scalar(@args) > 2) {
	$args[1] = join("=", @args[1..$#args]);
    }
    $arg = $args[0];
    if($arg eq "-b" || $arg eq "--bam") {
	$ht2_args[$i] = undef;
	$arg =~ s/^-b//; $arg =~ s/^--bam//;
	if($arg ne "") {
	    # Argument was part of this token
	    my @args = split(/,/, $arg);
	    for my $a (@args) { push @ht2w_args, ("-b", $a); }
	} else {
	    # Argument is in the next token
	    $i < scalar(@ht2_args)-1 || Fail("Argument expected in next token!\n");
	    $i++;
	    my @args = split(/,/, $ht2_args[$i]);
	    for my $a (@args) { push @ht2w_args, ("-b", $a); }
	    $ht2_args[$i] = undef;
	}
    }
    if($arg eq "--debug") {
	$debug = 1;
	$ht2_args[$i] = undef;
    }
}
# If the user asked us to redirect some reads to files, or to suppress
# unaligned reads, then we need to capture the output from HISAT and pass it
# through this wrapper.
my $passthru = 0;
if(scalar(keys %read_fns) > 0) {
    $passthru = 1;
    push @ht2_args, "--passthrough";
    $cap_out = "-";
    for(my $i = 0; $i < scalar(@ht2_args); $i++) {
	next unless defined($ht2_args[$i]);
	my $arg = $ht2_args[$i];
	if($arg eq "-S" || $arg eq "--output") {
	    $i < scalar(@ht2_args)-1 || Fail("-S/--output takes an argument.\n");
	    $cap_out = $ht2_args[$i+1];
	    $ht2_args[$i] = undef;
	    $ht2_args[$i+1] = undef;
	}
    }
}
my @tmp = ();
for (@ht2_args) { push(@tmp, $_) if defined($_); }
@ht2_args = @tmp;

my @bams = ();
my @to_delete = ();
my @to_kills = ();
my $temp_dir = "/tmp";
my $no_pipes = 0;
my $keep = 0;
my $verbose = 0;
my $readpipe = undef;
my $log_fName = undef;
my $help = 0;

my @ht2w_args_cp = (@ht2w_args>0) ? @ht2w_args : @ht2_args;
Getopt::Long::Configure("pass_through","no_ignore_case");

my @old_ARGV = @ARGV;
@ARGV = @ht2w_args_cp;

GetOptions(
    "bam|b=s"                       => \@bams,
    "temp-directory=s"              => \$temp_dir,
    "no-named-pipes"                => \$no_pipes,
    "keep"                          => \$keep,
    "verbose"                       => \$verbose,
    "log-file=s"                    => \$log_fName,
    "help|h"                        => \$help
);

@ARGV = @old_ARGV;

my $old_stderr;

if ($log_fName) {
    open($old_stderr, ">&STDERR") or Fail("Cannot dup STDERR!\n");
    open(STDERR, ">", $log_fName) or Fail("Cannot redirect to log file $log_fName.\n");
}

Info("Before arg handling:\n");
Info("  Wrapper args:\n[ @ht2w_args ]\n");
Info("  Binary args:\n[ @ht2_args ]\n");

# check read lengths
# if read_files have more than 1 files, use first one,

sub check_file_exist {
    my @bams = @_;
    for my $fn (@bams) {
	if (not -f $fn) {
	    Fail("Read file '%s' doesn't exist\n", $fn);
	    return 1;
	}
    }
    return 0;
}

sub cat_file($$) {
    my ($ifn, $ofh) = @_;
    my $ifh = undef;
    if($ifn =~ /\.bam$/) {
	open($ifh, "samtools view $ifn |") ||
	    Fail("Could not open gzipped read file: $ifn \n");
    } else {
	open($ifh, $ifn) || Fail("Could not open read file: $ifn \n");
    }
    while(readline $ifh) { print {$ofh} $_; }
    close($ifh);
}

# Return non-zero if and only if the input should be wrapped (i.e. because
# it's compressed).
sub wrapInput {
    my @bams = @_;
    for my $fn (@bams) {
	return 1 if $fn =~ /\.bam$/;
    }
    return 0;
}

sub Info {
    if ($verbose) {
        print STDERR "(INFO): " ,@_;
    }
}

sub Error {
    my @msg = @_;
    $msg[0] = "(ERR): ".$msg[0];
    printf STDERR @msg;
}

sub Fail {
    Error(@_);
    die("Exiting now ...\n");    
}

if($seq_in_args == 0) {
    check_file_exist(@bams);
}

if(wrapInput(@bams) > 0) {
    #
    # Wrap unpaired inputs.
    #
    # Make a named pipe for delivering unpaired reads
    my $ufn = "$temp_dir/$$.unp";
    push @to_delete, $ufn;
    push @ht2_args, "$ufn";
    # Create named pipe 2 for writing
    if(!$no_pipes) {
	mkfifo($ufn, 0700) || Fail("mkfifo($ufn) failed.\n");
    }
    my $pid = 0;
    $pid = fork() unless $no_pipes;
    if($pid == 0) {
	# Open named pipe 2 for writing
	open(my $ofh, ">$ufn") || Fail("Can't open '$ufn' for writing.\n");
	for my $ifn (@bams) { cat_file($ifn, $ofh); }
	close($ofh);
	exit 0 unless $no_pipes;
    }
}
else {
    if(scalar(@bams) > 0) {
	push @ht2_args, (join(",", @bams));
    }
}

Info("After arg handling:\n");
Info("  Binary args:\n[ @ht2_args ]\n");

my $debug_str = ($debug ? "-debug" : "");

# Construct command invoking hisat2-quant
my $cmd = "'$quant_prog$debug_str' ".join(" ", @ht2_args);

# Possibly add read input on an anonymous pipe
$cmd = "$readpipe $cmd" if defined($readpipe);

Info("$cmd\n");
my $ret = system($cmd);
kill 'TERM', @to_kills;

if(!$keep) { for(@to_delete) { unlink($_); } }

if ($ret == -1) {
    Error("Failed to execute hisat2-quant: $!\n");
	exit 1;
} elsif ($ret & 127) {
	my $signm = "(unknown)";
	$signm = $signame[$ret & 127] if defined($signame[$ret & 127]);
	my $ad = "";
	$ad = "(core dumped)" if (($ret & 128) != 0);
    Error("hisat2-quant died with signal %d (%s) $ad\n", ($ret & 127), $signm);
	exit 1;
} elsif($ret != 0) {
	Error("hisat2-quant exited with value %d\n", ($ret >> 8));
}
exit ($ret >> 8);

